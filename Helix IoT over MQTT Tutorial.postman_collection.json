{
	"info": {
		"_postman_id": "df318148-a974-4c37-85a4-a7ea91c1e4b0",
		"name": "Helix IoT over MQTT Tutorial",
		"description": "This tutorial uses introduces the use of the MQTT protocol across IoT devices connecting to Helix Sandbox. The\nUltraLight 2.0 IoT Agent is configured to communicate with a set of cell phone IoT devices from [IoT MQTT Panel](https://play.google.com/store/apps/details?id=snr.lab.iotmqttpanel.prod&hl=pt_BR) using MQTT via a [Mosquitto](https://mosquitto.org/) message broker.\n\n# Architecture\n\n<img src=\"https://github.com/fabiocabrini/helix-IoT-MQTT/blob/master/helixsandbox_v2_mqtt.jpg\">\n\n# Prerequisites\n\n## Servers\n\nYou'll need two instances and two public IPs to create this scenario by having the Helix Sandbox running on the CSP (Cloud Service Provider) and Helix IoT on the Raspberry/PC or you can create both on a local scenario.\n\n## Docker and Docker Compose\n\nTo keep things simple all components will be run using [Docker](https://www.docker.com). **Docker** is a container\ntechnology which allows to different components isolated into their respective environments.\n\n-   To install Docker on Linux follow the instructions [here](https://docs.docker.com/install/)\n\n**Docker Compose** is a tool for defining and running multi-container Docker applications. A\n[YAML file](https://raw.githubusercontent.com/Fiware/tutorials.IoT-over-MQTT/master/docker-compose.yml) is used\nconfigure the required services for the application. This means all container services can be brought up in a single\ncommand. Docker Compose is installed by default as part of Docker for Windows and Docker for Mac, however Linux users\nwill need to follow the instructions found [here](https://docs.docker.com/compose/install/)\n\nYou can check your current **Docker** and **Docker Compose** versions using the following commands:\n\n```console\ndocker-compose -v\ndocker version\n```\n\nPlease ensure that you are using Docker version 18.03 or higher and Docker Compose 1.21 or higher and upgrade if\nnecessary.\n\n# Start Up\n\nBefore you start you should ensure that you have obtained or built the necessary Docker images locally. Please clone the\nrepository and create the necessary images by running the commands as shown:\n\n```console\ngit clone https://github.com/fabiocabrini/Helix_IoT_MQTT.git\ncd Helix_IoT_MQTT\n\nsudo docker-compose up -d\n```\n\n## Checking the IoT Agent Service Health\n\nYou can check if the IoT Agent is running by making an HTTP request to the exposed port:\n\n#### :one: Request:\n\n```console\ncurl -X GET \\\n  'http://{{iot-agent}}:4041/iot/about'\n```\n\nThe response will look similar to the following:\n\n```json\n{\n    \"libVersion\": \"2.6.0-next\",\n    \"port\": \"4041\",\n    \"baseRoot\": \"/\",\n    \"version\": \"1.6.0-next\"\n}\n```\n\n\n## Connecting IoT Devices\n\nThe IoT Agent acts as a middleware between the IoT devices and the context broker. It therefore needs to be able to\ncreate context data entities with unique IDs. Once a service has been provisioned and an unknown device makes a\nmeasurement the IoT Agent add this to the context using the supplied `<device-id>` (unless the device is recognized and\ncan be mapped to a known ID.\n\nThere is no guarantee that every supplied IoT device `<device-id>` will always be unique, therefore all provisioning\nrequests to the IoT Agent require two mandatory headers:\n\n-   `fiware-service` header is defined so that entities for a given service can be held in a separate mongoDB database.\n-   `fiware-servicepath` can be used to differentiate between arrays of devices.\n\nFor example within a smart city application you would expect different `fiware-service` headers for different\ndepartments (e.g. parks, transport, refuse collection etc.) and each `fiware-servicepath` would refer to specific park\nand so on. This would mean that data and devices for each service can be identified and separated as needed, but the\ndata would not be siloed - for example data from a **Smart Bin** within a park can be combined with the **GPS Unit** of\na refuse truck to alter the route of the truck in an efficient manner.\n\nThe **Smart Bin** and **GPS Unit** are likely to come from different manufacturers and it cannot be guaranteed that\nthere is no overlap within `<device-id>`s used. The use of the `fiware-service` and `fiware-servicepath` headers can\nensure that this is always the case, and allows the context broker to identify the original source of the context data.\n\n### Provisioning a Service Group for MQTT\n\nInvoking group provision is always the first step in connecting devices. For MQTT communication, provisioning supplies\nthe authentication key so the IoT Agent will know which **topic** it must subscribe to.\n\nIt is possible to set up default commands and attributes for all devices as well, but this is not done within this\ntutorial as we will be provisioning each device separately.\n\nThis example provisions an anonymous group of devices. It tells the IoT Agent that a series of devices will be\ncommunicating by sending messages to the `/iot` **topic**\n\nThe `resource` attribute is left blank since HTTP communication is not being used. The URL location of `cbroker` is an\noptional attribute - if it is not provided, the IoT Agent uses the default context broker URL as defined in the\nconfiguration file, however it has been added here for completeness.\n\n#### :two: Request:\n\n```console\ncurl -iX POST \\\n  'http://{{iot-agent}}:4041/iot/services' \\\n  -H 'Content-Type: application/json' \\\n  -H 'fiware-service: helixiot' \\\n  -H 'fiware-servicepath: /' \\\n  -d '{\n \"services\": [\n   {\n     \"apikey\":      \"iot\",\n     \"cbroker\":     \"http://{{orion}}:1026\",\n     \"entity_type\": \"Thing\",\n     \"resource\":    \"\"\n   }\n ]\n}'\n```\n\n### Provisioning a Sensor\n\nIt is common good practice to use URNs following the NGSI-LD\n[specification](https://www.etsi.org/deliver/etsi_gs/CIM/001_099/009/01.01.01_60/gs_CIM009v010101p.pdf) when creating\nentities. Furthermore it is easier to understand meaningful names when defining data attributes. These mappings can be\ndefined by provisioning a device individually.\n\nThree types of measurement attributes can be provisioned:\n\n-   `attributes` are active readings from the device\n-   `lazy` attributes are only sent on request - The IoT Agent will inform the device to return the measurement\n-   `static_attributes` are as the name suggests static data about the device (such as relationships) passed on to the\n    context broker.\n\n> **Note**: in the case where individual `id`s are not required, or aggregated data is sufficient the `attributes` can\n> be defined within the provisioning service rather than individually.\n\n#### :three: Request:\n\n```console\ncurl -iX POST \\\n  'http://{{iot-agent}}:4041/iot/devices' \\\n  -H 'Content-Type: application/json' \\\n  -H 'fiware-service: helixiot' \\\n  -H 'fiware-servicepath: /' \\\n  -d '{\n \"devices\": [\n   {\n     \"device_id\":   \"motion001\",\n     \"entity_name\": \"urn:ngsi-ld:Motion:001\",\n     \"entity_type\": \"Motion\",\n     \"protocol\":    \"PDI-IoTA-UltraLight\",\n     \"transport\":   \"MQTT\",\n     \"timezone\":    \"America/Sao_Paulo\",\n     \"attributes\": [\n       { \"object_id\": \"c\", \"name\": \"count\", \"type\": \"Integer\" }\n     ]\n   }\n ]\n}\n'\n```\n\nIn the request we are associating the device `motion001` with the URN `urn:ngsi-ld:Motion:001` and mapping the device\nreading `c` with the context attribute `count` (which is defined as an `Integer`). \n\nThe addition of the `transport=MQTT` attribute in the body of the request is sufficient to tell the IoT Agent that it\nshould subscribe to the `/<api-key>/<device-id>` **topic** to receive measurements.\n\nYou can simulate a dummy IoT device measurement coming from the **Motion Sensor** device `motion001`, by posting an MQTT\nmessage to the following **topic**\n\nYou can see that a measurement has been recorded, by retrieving the entity data from the context broker. Don't forget to\nadd the `fiware-service` and `fiware-service-path` headers.\n\n#### :four: Request:\n\n```console\ncurl -X GET \\\n  'http://{{orion}}:1026/v2/entities/urn:ngsi-ld:Motion:001?type=Motion' \\\n  -H 'fiware-service: helixiot' \\\n  -H 'fiware-servicepath: /'\n```\n\n#### Response:\n\n```json\n{\n    \"id\": \"urn:ngsi-ld:Motion:001\",\n    \"type\": \"Motion\",\n    \"TimeInstant\": {\n        \"type\": \"DateTime\",\n        \"value\": \"2019-06-26T15:15:27.00Z\",\n        \"metadata\": {}\n    },\n    \"count\": {\n        \"type\": \"Integer\",\n        \"value\": \" \",\n        \"metadata\": {}\n    }\n}\n```\n\nThe response shows that the **Motion Sensor** device with `id=motion001` has been successfully identified by the IoT\nAgent and mapped to the entity `id=urn:ngsi-ld:Motion:001`. This new entity has been created within the context data.\nThe `c` attribute from the dummy device measurement request has been mapped to the more meaningful `count` attribute\nwithin the context. As you will notice, a `TimeInstant` attribute has been added to both the entity and the metadata of\nthe attribute - this represents the last time the entity and attribute have been updated, and is automatically added to\neach new entity because the `IOTA_TIMESTAMP` environment variable was set when the IoT Agent was started up.\n\n### Provisioning an Actuator\n\nProvisioning an actuator is similar to provisioning a sensor. The `transport=MQTT` attribute defines the communications\nprotocol to be used. For MQTT communications, the `endpoint` attribute is not required as there is no HTTP URL where the\ndevice is listening for commands. The array of commands is mapped to directly to messages sent to the\n`/<api-key>/<device-id>/cmd` **topic** The `commands` array includes a list of each command that can be invoked.\n\nThe example below provisions a bell with the `deviceId=bell001`.\n\n#### :five: Request:\n\n```console\ncurl -iX POST \\\n  'http://{{iot-agent}}:4041/iot/devices' \\\n  -H 'Content-Type: application/json' \\\n  -H 'fiware-service: helixiot' \\\n  -H 'fiware-servicepath: /' \\\n  -d '{\n  \"devices\": [\n    {\n      \"device_id\": \"bell001\",\n      \"entity_name\": \"urn:ngsi-ld:Bell:001\",\n      \"entity_type\": \"Bell\",\n      \"protocol\": \"PDI-IoTA-UltraLight\",\n      \"transport\": \"MQTT\",\n      \"commands\": [\n        { \"name\": \"ring\", \"type\": \"command\" }\n       ]\n    }\n  ]\n}\n'\n```\n\nBefore we wire-up the context broker, we can test that a command can be sent from the IoT Agent to a device by making a\nREST request directly to the IoT Agent's North Port using the `/v1/updateContext` endpoint. It is this endpoint that\nwill eventually be invoked by the context broker once we have connected it up. To test the configuration you can run the\ncommand directly as shown:\n\n#### :six: Request:\n\n```console\ncurl -iX POST \\\n  'http://{{iot-agent}}:4041/v1/updateContext' \\\n  -H 'Content-Type: application/json' \\\n  -H 'fiware-service: helixiot' \\\n  -H 'fiware-servicepath: /' \\\n  -d '{\n    \"contextElements\": [\n        {\n            \"type\": \"Bell\",\n            \"isPattern\": \"false\",\n            \"id\": \"urn:ngsi-ld:Bell:001\",\n            \"attributes\": [\n                { \"name\": \"ring\", \"type\": \"command\", \"value\": \"\" }\n            ]\n        }\n    ],\n    \"updateAction\": \"UPDATE\"\n}'\n```\n\n#### Response:\n\n```json\n{\n    \"contextResponses\": [\n        {\n            \"contextElement\": {\n                \"attributes\": [\n                    {\n                        \"name\": \"ring\",\n                        \"type\": \"command\",\n                        \"value\": \"\"\n                    }\n                ],\n                \"id\": \"urn:ngsi-ld:Bell:001\",\n                \"isPattern\": false,\n                \"type\": \"Bell\"\n            },\n            \"statusCode\": {\n                \"code\": 200,\n                \"reasonPhrase\": \"OK\"\n            }\n        }\n    ]\n}\n```\n\nThe result of the command to ring the bell can be read by querying the entity within the Orion Context Broker.\n\n#### :seven: Request:\n\n```console\ncurl -X GET \\\n  'http://{{orion}}:1026/v2/entities/urn:ngsi-ld:Bell:001?type=Bell&options=keyValues' \\\n  -H 'fiware-service: helixiot' \\\n  -H 'fiware-servicepath: /'\n```\n\n#### Response:\n\n```json\n{\n    \"id\": \"urn:ngsi-ld:Bell:001\",\n    \"type\": \"Bell\",\n    \"TimeInstant\": {\n        \"type\": \"DateTime\",\n        \"value\": \"2019-06-26T15:29:52.00Z\",\n        \"metadata\": {}\n    },\n    \"ring_info\": {\n        \"type\": \"commandResult\",\n        \"value\": \" \",\n        \"metadata\": {}\n    },\n    \"ring_status\": {\n        \"type\": \"commandStatus\",\n        \"value\": \"PENDING\",\n        \"metadata\": {\n            \"TimeInstant\": {\n                \"type\": \"DateTime\",\n                \"value\": \"2019-06-26T15:29:52.00Z\"\n            }\n        }\n    },\n    \"ring\": {\n        \"type\": \"command\",\n        \"value\": \"\",\n        \"metadata\": {}\n    }\n}\n```\n\nThe `TimeInstant` shows last the time any command associated with the entity has been invoked. The result of `ring`\ncommand can be seen in the value of the `ring_info` attribute.\n\n### Provisioning a Smart Door\n\nProvisioning a device which offers both commands and measurements is merely a matter of making an HTTP POST request with\nboth `attributes` and `command` attributes in the body of the request. Once again the `transport=MQTT` attribute defines\nthe communications protocol to be used, and no `endpoint` attribute is required as there is no HTTP URL where the device\nis listening for commands.\n\n#### :eight: Request:\n\n```console\ncurl -iX POST \\\n  'http://{{iot-agent}}:4041/iot/devices' \\\n  -H 'Content-Type: application/json' \\\n  -H 'fiware-service: helixiot' \\\n  -H 'fiware-servicepath: /' \\\n  -d '{\n  \"devices\": [\n    {\n      \"device_id\": \"door001\",\n      \"entity_name\": \"urn:ngsi-ld:Door:001\",\n      \"entity_type\": \"Door\",\n      \"protocol\": \"PDI-IoTA-UltraLight\",\n      \"transport\": \"MQTT\",\n      \"commands\": [\n        {\"name\": \"unlock\",\"type\": \"command\"},\n        {\"name\": \"open\",\"type\": \"command\"},\n        {\"name\": \"close\",\"type\": \"command\"},\n        {\"name\": \"lock\",\"type\": \"command\"}\n       ],\n       \"attributes\": [\n        {\"object_id\": \"s\", \"name\": \"state\", \"type\":\"Text\"}\n       ]\n    }\n  ]\n}\n'\n```\n\n### Provisioning a Smart Lamp\n\nSimilarly, a **Smart Lamp** with two commands (`on` and `off`) and two attributes can be provisioned as follows:\n\n#### :nine: Request:\n\n```console\ncurl -iX POST \\\n  'http://{{iot-agent}}:4041/iot/devices' \\\n  -H 'Content-Type: application/json' \\\n  -H 'fiware-service: helixiot' \\\n  -H 'fiware-servicepath: /' \\\n  -d '{\n  \"devices\": [\n    {\n      \"device_id\": \"lamp001\",\n      \"entity_name\": \"urn:ngsi-ld:Lamp:001\",\n      \"entity_type\": \"Lamp\",\n      \"protocol\": \"PDI-IoTA-UltraLight\",\n      \"transport\": \"MQTT\",\n      \"commands\": [\n        {\"name\": \"on\",\"type\": \"command\"},\n        {\"name\": \"off\",\"type\": \"command\"}\n       ],\n       \"attributes\": [\n        {\"object_id\": \"s\", \"name\": \"state\", \"type\":\"Text\"},\n        {\"object_id\": \"l\", \"name\": \"luminosity\", \"type\":\"Integer\"}\n       ]\n    }\n  ]\n}\n'\n```\n\nThe full list of provisioned devices can be obtained by making a GET request to the `/iot/devices` endpoint.\n\n#### :one::zero: Request:\n\n```console\ncurl -X GET \\\n  'http://{{iot-agent}}:4041/iot/devices' \\\n  -H 'fiware-service: helixiot' \\\n  -H 'fiware-servicepath: /'\n```\n\n## Enabling Context Broker Commands\n\nHaving connected up the IoT Agent to the IoT devices, we now need to inform the Orion Context Broker that the commands\nare available. In other words we need to register the IoT Agent as a\n[Context Provider](https://github.com/FIWARE/tutorials.Context-Providers/) for the command attributes.\n\nOnce the commands have been registered it will be possible to ring the **Bell**, open and close the **Smart Door** and\nswitch the **Smart Lamp** on and off by sending requests to the Orion Context Broker, rather than sending UltraLight 2.0\nrequests directly the IoT devices as we did in the [previous tutorial](https://github.com/FIWARE/tutorials.IoT-Sensors)\n\nAll the communications leaving and arriving at the North port of the IoT Agent use the standard NGSI syntax. The\ntransport protocol used between the IoT devices and the IoT Agent is irrelevant to this layer of communication.\nEffectively the IoT Agent is offering a simplified facade pattern of well-known endpoints to actuate any device.\n\nTherefore this section of registering and invoking commands **duplicates** the instructions found in the\n[previous tutorial](https://github.com/FIWARE/tutorials.IoT-Agent)\n\n### Registering a Bell Command\n\nThe **Bell** entity has been mapped to `id=\"urn:ngsi-ld:Bell:001\"` with an entity `type=\"Bell\"`. To register the command\nwe need to inform Orion that the URL `http://{{orion}}:1026/v1` is able to provide the missing `ring` attribute. This will\nthen be forwarded on to the IoT Agent. As you see this is an NGSI v1 endpoint and therefore the `legacyForwarding`\nattribute must also be set.\n\n#### :one::one: Request:\n\n```console\ncurl -iX POST \\\n  'http://{{orion}}:1026/v2/registrations' \\\n  -H 'Content-Type: application/json' \\\n  -H 'fiware-service: helixiot' \\\n  -H 'fiware-servicepath: /' \\\n  -d '{\n  \"description\": \"Bell Commands\",\n  \"dataProvided\": {\n    \"entities\": [\n      {\n        \"id\": \"urn:ngsi-ld:Bell:001\", \"type\": \"Bell\"\n      }\n    ],\n    \"attrs\": [\"ring\"]\n  },\n  \"provider\": {\n    \"http\": {\"url\": \"http://{{iot-agent}}:4041\"},\n    \"legacyForwarding\": true\n  }\n}'\n```\n\n### Ringing the Bell\n\nTo invoke the `ring` command, the `ring` attribute must be updated in the context.\n\n#### :one::two: Request:\n\n```console\ncurl -iX PATCH \\\n  'http://{{orion}}:1026/v2/entities/urn:ngsi-ld:Bell:001/attrs' \\\n  -H 'Content-Type: application/json' \\\n  -H 'fiware-service: helixiot' \\\n  -H 'fiware-servicepath: /' \\\n  -d '{\n  \"ring\": {\n      \"type\" : \"command\",\n      \"value\" : \"\"\n  }\n}'\n```\n\nIf you are viewing the device monitor page, you can also see the state of the bell change.\n\n\n### Registering Smart Door Commands\n\nThe **Smart Door** entity has been mapped to `id=\"urn:ngsi-ld:Door:001\"` with an entity `type=\"Door\"`. To register the\ncommands we need to inform Orion that the URL `http://orion:1026/v1` is able to provide the missing attributes. This\nwill then be forwarded on to the IoT Agent. As you see this is an NGSI v1 endpoint and therefore the `legacyForwarding`\nattribute must also be set.\n\n#### :one::three: Request:\n\n```console\ncurl -iX POST \\\n  'http://{{orion}}:1026/v2/registrations' \\\n  -H 'Content-Type: application/json' \\\n  -H 'fiware-service: helixiot' \\\n  -H 'fiware-servicepath: /' \\\n  -d '{\n  \"description\": \"Door Commands\",\n  \"dataProvided\": {\n    \"entities\": [\n      {\n        \"id\": \"urn:ngsi-ld:Door:001\", \"type\": \"Door\"\n      }\n    ],\n    \"attrs\": [ \"lock\", \"unlock\", \"open\", \"close\"]\n  },\n  \"provider\": {\n    \"http\": {\"url\": \"http://{{iot-agent}}:4041\"},\n    \"legacyForwarding\": true\n  }\n}'\n```\n\n### Opening the Smart Door\n\nTo invoke the `open` command, the `open` attribute must be updated in the context.\n\n#### :one::four: Request:\n\n```console\ncurl -iX PATCH \\\n  'http://{{orion}}:1026/v2/entities/urn:ngsi-ld:Lamp:001/attrs' \\\n  -H 'Content-Type: application/json' \\\n  -H 'fiware-service: helixiot' \\\n  -H 'fiware-servicepath: /' \\\n  -d '{\n  \"open\": {\n      \"type\" : \"command\",\n      \"value\" : \"\"\n  }\n}'\n```\n\n### Registering Smart Lamp Commands\n\nThe **Smart Lamp** entity has been mapped to `id=\"urn:ngsi-ld:Lamp:001\"` with an entity `type=\"Lamp\"`. To register the\ncommands we need to inform Orion that the URL `http://orion:1026/v1` is able to provide the missing attributes. This\nwill then be forwarded on to the IoT Agent. As you see this is an NGSI v1 endpoint and therefore the `legacyForwarding`\nattribute must also be set.\n\n#### :one::five: Request:\n\n```console\ncurl -iX POST \\\n  'http://{{orion}}:1026/v2/registrations' \\\n  -H 'Content-Type: application/json' \\\n  -H 'fiware-service: helixiot' \\\n  -H 'fiware-servicepath: /' \\\n  -d '{\n  \"description\": \"Lamp Commands\",\n  \"dataProvided\": {\n    \"entities\": [\n      {\n        \"id\": \"urn:ngsi-ld:Lamp:001\",\"type\": \"Lamp\"\n      }\n    ],\n    \"attrs\": [ \"on\", \"off\" ]\n  },\n  \"provider\": {\n    \"http\": {\"url\": \"http://{{iot-agent}}:4041\"},\n    \"legacyForwarding\": true\n  }\n}'\n```\n\n### Switching on the Smart Lamp\n\nTo switch on the **Smart Lamp**, the `on` attribute must be updated in the context.\n\n#### :one::six: Request:\n\n```console\ncurl -iX PATCH \\\n  'http://{{orion}}:1026/v2/entities/urn:ngsi-ld:Lamp:001/attrs' \\\n  -H 'Content-Type: application/json' \\\n  -H 'fiware-service: helixiot' \\\n  -H 'fiware-servicepath: /' \\\n  -d '{\n  \"on\": {\n      \"type\" : \"command\",\n      \"value\" : \"\"\n  }\n}'\n```\n\n## Reference\n\nThis tutorial is adapted from [Fiware Foundation](https://github.com/FIWARE/tutorials.IoT-over-MQTT)\n\n\n#### © Helix Platform 2019, All rights reserved.\n",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json"
	},
	"item": [
		{
			"name": "Checking Mosquitto Health",
			"item": [],
			"description": "We will start by mimicking the roles of both the IoT Agent and a dummy IoT device and send and receive some messages\nusing MQTT. This section of the tutorial requires several open terminals.\n\n### Start an MQTT Subscriber (1st Terminal)\n\nEventually once we have wired by the system correctly, IoT Agent will subscribe to all relevent events to listen for\nnorthbound traffic in the form of sensor measurements. It therefore will need to make a subscription\nacross all topics. Similarly an accuator must subscribe to a single topic to receive events which effect itself when \ncommands are sent southbound. To check that the lines of communication are open, we can subscribe to a given topic,\nand see that we are able to receive something when a message is published.\n\nOpen a **new terminal**, and create a new running `mqtt-subscriber` Docker container as follows:\n\n```console\ndocker run -it --rm --name mqtt-subscriber \\\n  --network fiware_default efrecon/mqtt-client sub -h mosquitto -t \"#\"\n```\n\nThe terminal will then be ready to receive events\n\n### Start an MQTT Publisher (2nd Terminal)\n\nA sensor sending northbound measurements will publish to those measurements to the MQTT Broker to be passed on to \nany subscriber than  wants them. The sensor will not need to make a connection to the subscriber directly. \n\nOpen a **new terminal**, and run a  `mqtt-publisher` Docker container to send a message as follows:\n\n```console\ndocker run -it --rm -name mqtt-publisher \\\n  --network fiware_default efrecon/mqtt-client pub -h mosquitto -m \"HELLO WORLD\" -t \"test\"\n```\n\n#### 1st terminal - Result:\n\nIf the MQTT Broker is functioning correctly, the message should be received in the other terminal\n\n```\nHELLO WORLD\n```\n\n\n### Stop an MQTT Subscriber (1st Terminal)\n\nTo terminate the MQTT subscriber, run the following Docker command:\n\n```console\ndocker stop mqtt-subscriber\n```\n\n### Show Mosquitto Log\n\nTo show that the communication occurred via the **MQTT Broker**, we can inspect the log of the `mosquitto` Docker container as shown:\n\n```console\ndocker logs --tail 10 mosquitto\n```\n\n#### Result:\n\n```\n1529661883: New client connected from 172.18.0.5 as mqttjs_8761e518 (c1, k0).\n1529662472: New connection from 172.18.0.7 on port 1883.\n1529662472: New client connected from 172.18.0.7 as mosqpub|1-5637527c63c1 (c1, k60).\n1529662472: Client mosqpub|1-5637527c63c1 disconnected.\n1529662614: New connection from 172.18.0.7 on port 1883.\n1529662614: New client connected from 172.18.0.7 as mosqsub|1-64b27d675f58 (c1, k60).\n1529662623: New connection from 172.18.0.8 on port 1883.\n1529662623: New client connected from 172.18.0.8 as mosqpub|1-ef03e74b0270 (c1, k60).\n1529662623: Client mosqpub|1-ef03e74b0270 disconnected.\n1529667841: Socket error on client mosqsub|1-64b27d675f58, disconnecting.\n```\n",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"id": "c6502f9d-8906-46d9-bb87-c141718201de",
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"id": "f7419bd0-dfb9-4fd4-8b5e-d8543b7e92fc",
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Connecting IoT Devices",
			"item": [
				{
					"name": "IoT Agent - Obtain Version Information",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "http://{{iot-agent}}:4041/iot/about",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"about"
							]
						},
						"description": "Once the IoT Agent is running, You can check the status by making an HTTP request to the exposed port. \nIf the response is blank, this is usually because the MongoDB database holding the context information is not running or not connected.\n\n>**Troubleshooting:** What if the response is blank ?\n>\n> * To check that a docker container is running try\n>\n>```bash\n>docker ps\n>```\n>\n>You should see several containers running. If `iot-agent` is not running, you can restart the containers as necessary."
					},
					"response": []
				},
				{
					"name": "IoT Agent - Create a Service Group",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "helixiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n \"services\": [\n   {\n     \"apikey\":      \"iot\",\n     \"cbroker\":     \"http://{{orion}}:1026\",\n     \"entity_type\": \"Thing\",\n     \"resource\":    \"\"\n   }\n ]\n}"
						},
						"url": {
							"raw": "http://{{iot-agent}}:4041/iot/services",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"services"
							]
						},
						"description": "Invoking group provision is always the the first step in connecting devices. For MQTT communication, provisioning supplies the authentication key so the IoT Agent will know which **topic** it must\nsubscribe to.\n\nIt is possible to set up default commands and attributes for all devices as well, but this\nis not done within this tutorial as we will be provisioning each device separately.\n\nThis example provisions an anonymous group of devices. It tells the IoT Agent that a series of devices\nwill be communicating by sending messages to the `/4jggokgpepnvsb2uv4s40d59ov` **topic**\n\nThe `resource` attribute is left blank since HTTP communication is not being used.\n\nThe URL location of  `cbroker` is an optional attribute - if it is not provided, the IoT\nAgent uses the default context broker URL as defined in the configuration file, however\nit has been added here for completeness."
					},
					"response": []
				},
				{
					"name": "IoT Agent - Provision a Sensor",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "helixiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n \"devices\": [\n   {\n     \"device_id\":   \"motion001\",\n     \"entity_name\": \"urn:ngsi-ld:Motion:001\",\n     \"entity_type\": \"Motion\",\n     \"protocol\":    \"PDI-IoTA-UltraLight\",\n     \"transport\":   \"MQTT\",\n     \"timezone\":    \"America/Sao_Paulo\",\n     \"attributes\": [\n       { \"object_id\": \"c\", \"name\":\"count\", \"type\":\"Integer\"}\n      ]\n   }\n ]\n}\n"
						},
						"url": {
							"raw": "http://{{iot-agent}}:4041/iot/devices",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices"
							]
						},
						"description": "It is common good practice to use URNs following the NGSI-LD [specification](https://www.etsi.org/deliver/etsi_gs/CIM/001_099/009/01.01.01_60/gs_CIM009v010101p.pdf) when creating entities. Furthermore it is easier to understand\nmeaningful names when defining data attributes. These mappings can be defined by provisioning a device individually.\n\nThree types of meaasurement attributes can be provisioned:\n\n* `attributes` are active readings from the device\n* `lazy` attributes are only sent on request -  The IoT Agent will inform the device to return the measurement\n* `static_attributes` are as the name suggests static data about the device (such as relationships) passed on \n  to the context broker.\n\n>**Note**: in the case where individual `id`s are not required, or aggregated data is sufficient \n> the `attributes` can be defined within the provisioning service rather than individually.\n\nIn the request we are assiociating the device `motion001` with the URN `urn:ngsi-ld:Motion:001`\nand mapping the device reading `c` with the context attribute `count` (which is defined as an `Integer`)\nA `refStore` is defined as a `static_attribute`, placing the device within **Store** `urn:ngsi-ld:Store:001`"
					},
					"response": []
				},
				{
					"name": "Context Broker - Read the Motion Sensor",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "fiware-service",
								"value": "helixiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							}
						],
						"url": {
							"raw": "http://{{orion}}:1026/v2/entities/urn:ngsi-ld:Motion:001",
							"protocol": "http",
							"host": [
								"{{orion}}"
							],
							"path": [
								"v2",
								"entities",
								"urn:ngsi-ld:Motion:001"
							]
						},
						"description": "To make a dummy measurement, send a topic to the **MQTT Broker** as shown.\n\n```\ndocker run -it --rm --name mqtt-publisher --network \\\n  fiware_default efrecon/mqtt-client pub -h mosquitto -m \"c|1\" -t \"/4jggokgpepnvsb2uv4s40d59ov/motion001/attrs\"\n```\n\n\nThen make the context data request.\n\nThis example returns the data for the `Motion` entity with the `id=urn:ngsi-ld:Motion:001` within the context data.\n\nThe response shows that the device with `id=motion001` has been successfully identifed by the IoT Agent and mapped to the\nentity `id=urn:ngsi-ld:Motion:001`. This new entity has been created within the context data. The `c` \nattribute from the dummy device measurement request has been mapped to the more meaningful `count` attribute\nwithin the context. As you will notice, a `TimeInstant` attribute has been added to both the entity and the\nmeta data of the attribute - this represents the last time the entity and attribute have been updated, and is\nautomatically added to each new entity because the `IOTA_TIMESTAMP`  environment variable was set when the\nIoT Agent was started up."
					},
					"response": []
				},
				{
					"name": "IoT Agent - Provision an Actuator",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "helixiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"devices\": [\n    {\n      \"device_id\": \"bell001\",\n      \"entity_name\": \"urn:ngsi-ld:Bell:001\",\n      \"entity_type\": \"Bell\",\n      \"protocol\": \"PDI-IoTA-UltraLight\",\n      \"transport\": \"MQTT\",\n      \"commands\": [ \n        {\n          \"name\": \"ring\",\n          \"type\": \"command\"\n        }\n       ]\n    }\n  ]\n}\n"
						},
						"url": {
							"raw": "http://{{iot-agent}}:4041/iot/devices",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices"
							]
						},
						"description": "Provisioning an actuator is similar to provisioning a sensor. The `transport` attribute defines the communications\nprotocol to be used. For MQTT communications, the `endpoint` attribute  is not required as there is no HTTP url \nwhere the device is listening for commands.  The array of commands\nis mapped to directly to messages sent to the  `/<api-key>/<device-id>/cmd` **topic** \nThe `commands` array includes a list of each command that can be invoked. \n\nThe example below provisions a bell with the `deviceId=bell001`."
					},
					"response": []
				},
				{
					"name": "IoT Agent - Invoke a Command",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "helixiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"contextElements\": [\n        {\n            \"type\": \"Bell\",\n            \"isPattern\": \"false\",\n            \"id\": \"urn:ngsi-ld:Bell:001\",\n            \"attributes\": [\n                {\n                    \"name\": \"ring\",\n                    \"type\": \"command\",\n                    \"value\": \"\"\n                }\n            ]\n        }\n    ],\n    \"updateAction\": \"UPDATE\"\n}"
						},
						"url": {
							"raw": "http://{{iot-agent}}:4041/v1/updateContext",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"v1",
								"updateContext"
							]
						},
						"description": "Before we wire-up the context broker, we can test that a command can be sent from the IoT Agent to a\ndevice by making a REST request directly to the IoT Agent's North Port using the `/v1/updateContext` endpoint.\nIt is this endpoint that will eventually be invoked by the context broker once we have connected it up.\nTo test the configuration you can run the command directly as shown.\n\nIf you are viewing the device monitor page, you can also see the state of the bell change.\n\n![](https://fiware.github.io/tutorials.IoT-Agent/img/bell-ring.gif)"
					},
					"response": []
				},
				{
					"name": "Context Broker - Read the Command Result",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "fiware-service",
								"value": "helixiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							}
						],
						"url": {
							"raw": "http://{{orion}}:1026/v2/entities/urn:ngsi-ld:Bell:001?options=keyValues",
							"protocol": "http",
							"host": [
								"{{orion}}"
							],
							"path": [
								"v2",
								"entities",
								"urn:ngsi-ld:Bell:001"
							],
							"query": [
								{
									"key": "options",
									"value": "keyValues"
								}
							]
						},
						"description": "The result of the command to ring the bell can be read by querying the entity within the Orion Context Broker. \n\nThe `TimeInstant` shows last the time any command associated with the entity has been invoked. the result of `ring` command can be see in the value of the `ring_info` attribute"
					},
					"response": []
				},
				{
					"name": "IoT Agent - Provision a Smart Door",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "helixiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"devices\": [\n    {\n      \"device_id\": \"door001\",\n      \"entity_name\": \"urn:ngsi-ld:Door:001\",\n      \"entity_type\": \"Door\",\n      \"protocol\": \"PDI-IoTA-UltraLight\",\n      \"transport\": \"MQTT\",\n      \"commands\": [ \n        {\"name\": \"unlock\",\"type\": \"command\"},\n        {\"name\": \"open\",\"type\": \"command\"},\n        {\"name\": \"close\",\"type\": \"command\"},\n        {\"name\": \"lock\",\"type\": \"command\"}\n       ],\n       \"attributes\": [\n       \t{\"object_id\": \"s\", \"name\": \"state\", \"type\":\"Text\"}\n       ]\n    }\n  ]\n}\n"
						},
						"url": {
							"raw": "http://{{iot-agent}}:4041/iot/devices",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices"
							]
						},
						"description": "Provisioning  a device which offers both commands and measurements is merely a matter of \nmaking an HTTP POST request with both `attributes` and `command` attributes in the body of the \nrequest. Once again the `transport=MQTT` attribute defines the communications protocol to be used, \nand no `endpoint` attribute is required as there is no HTTP url where the device is listening \nfor commands."
					},
					"response": []
				},
				{
					"name": "IoT Agent - Provision a Smart Lamp",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "fiware-service",
								"value": "helixiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n  \"devices\": [\n    {\n      \"device_id\": \"lamp001\",\n      \"entity_name\": \"urn:ngsi-ld:Lamp:001\",\n      \"entity_type\": \"Lamp\",\n      \"protocol\": \"PDI-IoTA-UltraLight\",\n      \"transport\": \"MQTT\",\n      \"commands\": [ \n        {\"name\": \"on\",\"type\": \"command\"},\n        {\"name\": \"off\",\"type\": \"command\"}\n       ],\n       \"attributes\": [\n       \t{\"object_id\": \"s\", \"name\": \"state\", \"type\":\"Text\"},\n        {\"object_id\": \"l\", \"name\": \"luminosity\", \"type\":\"Integer\"}\n       ]\n    }\n  ]\n}\n"
						},
						"url": {
							"raw": "http://{{iot-agent}}:4041/iot/devices",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices"
							]
						},
						"description": "Provisioning  a device which offers both commands and measurements is merely a matter of making an HTTP POST request\nwith both `attributes` and `command` attributes in the body of the request.\n\nThis example provisions a smart door with two commands `on` and `off` and maps two attributes."
					},
					"response": []
				},
				{
					"name": "IoT Agent - List all Provisioned Devices",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "fiware-service",
								"value": "helixiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							}
						],
						"url": {
							"raw": "http://{{iot-agent}}:4041/iot/devices",
							"protocol": "http",
							"host": [
								"{{iot-agent}}"
							],
							"path": [
								"iot",
								"devices"
							]
						},
						"description": "This example lists all provisioned devices by making a GET request to the `/iot/devices` endpoint.\n\nThe response includes all the commands and attributes mappings associated with all provisioned IoT devices."
					},
					"response": []
				}
			],
			"description": "The IoT Agent acts as a middleware between the IoT devices and the context broker. It therefore\nneeds to be able to create context data entities with unique ids.  Once a service has been provisioned\nand an unknown device makes a measurement the IoT Agent add this to the context using the supplied\n`<device-id>` (unless the device is recognized and can be mapped to a known id.\n\nThere is no guarantee that every supplied IoT device `<device-id>` will always be unique, therefore \nall provisioning requests to the IoT Agent require two mandatory headers:\n\n* `fiware-service` header is defined so that entities for a given service can be held in a separate mongoDB database.\n* `fiware-servicepath` can be used to differenciate between arrays of devices. \n\nFor example within a smart city application you would expect different `fiware-service` headers for different\ndepartments (e.g. parks, transport, refuse collection etc.) and each `fiware-servicepath`  would refer to specific park \nand so on. This would mean that data and devices for each service can be identified and separated as needed, but the\ndata would not be siloed - for example data from a  **Smart Bin** within a park can be combined with the **GPS Unit** \nof a refuse truck to alter the route of the truck in an efficient manner. \n\nThe **Smart Bin** and **GPS Unit** are likely to come from different manufacturers and it cannot be \nguaranteed that that there is no overlap within `<device-ids>`s used. The use of the  `fiware-service` and\n`fiware-servicepath` headers can ensure that this is always the case, and allows the context broker to identify\nthe original source of the context data.\n",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"id": "661d9977-6eda-41bc-ab3a-5ab127cf21a5",
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"id": "1c47421c-2f50-4cee-add5-99cb44744a53",
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		},
		{
			"name": "Enabling Context Broker Commands",
			"item": [
				{
					"name": "Bell Commands",
					"item": [
						{
							"name": "Register Bell Commands",
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "fiware-service",
										"value": "helixiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"description\": \"Bell Commands\",\n  \"dataProvided\": {\n    \"entities\": [\n      {\n        \"id\": \"urn:ngsi-ld:Bell:001\", \"type\": \"Bell\"\n      }\n    ],\n    \"attrs\": [\"ring\"]\n  },\n  \"provider\": {\n    \"http\": {\"url\": \"http://{{iot-agent}}:4041\"},\n    \"legacyForwarding\": true\n  }\n}"
								},
								"url": {
									"raw": "http://{{orion}}:1026/v2/registrations?",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"registrations"
									],
									"query": [
										{
											"key": "type",
											"value": "Store",
											"description": "Entity type, to avoid ambiguity in case there are several entities with the same entity id",
											"disabled": true
										},
										{
											"key": "attrs",
											"value": "name",
											"description": "Ordered list of attribute names to display",
											"disabled": true
										}
									]
								},
								"description": "This example registers the `ring` command for the entity with the `id=\"urn:ngsi-ld:Bell:001\"`\n\nTo register the command we need to inform Orion that the URL `http://orion:1026/v1` is able to provide\nthe missing `ring` attribute. This will then be forwarded on to the IoT Agent. As you see this is an NGSI v1 \nendpoint and therefore the `legacyForwarding` attribute must also be set."
							},
							"response": []
						},
						{
							"name": "Ring Bell",
							"request": {
								"method": "PATCH",
								"header": [
									{
										"key": "fiware-service",
										"value": "helixiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n\t\"ring\": {\n    \t\"type\" : \"command\",\n    \t\"value\" : \"\"\n\t}\n}"
								},
								"url": {
									"raw": "http://{{orion}}:1026/v2/entities/urn:ngsi-ld:Bell:001/attrs",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"entities",
										"urn:ngsi-ld:Bell:001",
										"attrs"
									]
								},
								"description": "To invoke the `ring` command, the `ring` attribute must be updated in the context.\n\nIf you are viewing the device monitor page, you can also see the state of the bell change.\n\n![](https://fiware.github.io/tutorials.IoT-Agent/img/bell-ring.gif)"
							},
							"response": []
						},
						{
							"name": "Bell Status",
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "fiware-service",
										"value": "helixiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									}
								],
								"url": {
									"raw": "http://{{orion}}:1026/v2/entities/urn:ngsi-ld:Bell:001?options=keyValues",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"entities",
										"urn:ngsi-ld:Bell:001"
									],
									"query": [
										{
											"key": "options",
											"value": "keyValues"
										}
									]
								},
								"description": "The result of the command to ring the bell can be read by querying the entity within the Orion Context Broker. \n\nThe `TimeInstant` shows last the time any command associated with the entity has been invoked. the result of `ring` command can be see in the value of the `ring_info` attribute"
							},
							"response": []
						}
					],
					"description": "The **Bell** entity has been mapped to `id=\"urn:ngsi-ld:Bell:001\"` with an entity `type=\"Bell\"`",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"id": "03f1d3da-6cdb-4a0a-bc49-3d970f1c4a06",
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"id": "4b157849-2b5c-42a6-b5f3-786fe212a846",
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					],
					"_postman_isSubFolder": true
				},
				{
					"name": "Smart Door Commands",
					"item": [
						{
							"name": "Register Smart Door Commands",
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "fiware-service",
										"value": "helixiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"description\": \"Door Commands\",\n  \"dataProvided\": {\n    \"entities\": [\n      {\n        \"id\": \"urn:ngsi-ld:Door:001\", \"type\": \"Door\"\n      }\n    ],\n    \"attrs\": [ \"lock\", \"unlock\", \"open\", \"close\"]\n  },\n  \"provider\": {\n    \"http\": {\"url\": \"http://{{iot-agent}}:4041\"},\n    \"legacyForwarding\": true\n  }\n}"
								},
								"url": {
									"raw": "http://{{orion}}:1026/v2/registrations?",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"registrations"
									],
									"query": [
										{
											"key": "type",
											"value": "Store",
											"description": "Entity type, to avoid ambiguity in case there are several entities with the same entity id",
											"disabled": true
										},
										{
											"key": "attrs",
											"value": "name",
											"description": "Ordered list of attribute names to display",
											"disabled": true
										}
									]
								},
								"description": "This example registers the `lock`, `unlock`, `open` and `close` commands for the entity with\nthe `id=\"urn:ngsi-ld:Door:001\"`\n\nTo register the commands we need to inform Orion that the URL `http://orion:1026/v1` is able to provide\nthe missing  attributes. This will then be forwarded on to the IoT Agent. As you see this is an NGSI v1 \nendpoint and therefore the `legacyForwarding` attribute must also be set."
							},
							"response": []
						},
						{
							"name": "Open a Door",
							"request": {
								"method": "PATCH",
								"header": [
									{
										"key": "fiware-service",
										"value": "helixiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n\t\"open\": {\n    \t\"type\" : \"command\",\n    \t\"value\" : \"\"\n\t}\n}"
								},
								"url": {
									"raw": "http://{{orion}}:1026/v2/entities/urn:ngsi-ld:Door:001/attrs",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"entities",
										"urn:ngsi-ld:Door:001",
										"attrs"
									]
								},
								"description": "To invoke the `open` command, the `open` attribute must be updated in the context."
							},
							"response": []
						},
						{
							"name": "Door Status",
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "fiware-service",
										"value": "helixiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									}
								],
								"url": {
									"raw": "http://{{orion}}:1026/v2/entities/urn:ngsi-ld:Door:001?options=keyValues",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"entities",
										"urn:ngsi-ld:Door:001"
									],
									"query": [
										{
											"key": "options",
											"value": "keyValues"
										}
									]
								},
								"description": "The result of the invocation of **Smart Door** commands can be read by querying the entity within the Orion Context Broker. \n\nThe `TimeInstant` shows last the time any command associated with the entity has been invoked. \n\n* The result of `open` command can be see in the value of the `open_info` attribute\n* The result of `close` command can be see in the value of the `close_info` attribute\n* The result of `lock` command can be see in the value of the `lock_info` attribute\n* The result of `unlock` command can be see in the value of the `unlock_info` attribute"
							},
							"response": []
						}
					],
					"description": "The **Smart Door** entity has been mapped to `id=\"urn:ngsi-ld:Door:001\"` with an entity `type=\"Door\"`",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"id": "bd93a337-b87f-4f47-9aca-604325c80bec",
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"id": "062e5306-e534-49d9-ac6c-df5d71317195",
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					],
					"_postman_isSubFolder": true
				},
				{
					"name": "Smart Lamp",
					"item": [
						{
							"name": "Register Smart Lamp Commands",
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json"
									},
									{
										"key": "fiware-service",
										"value": "helixiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n  \"description\": \"Lamp Commands\",\n  \"dataProvided\": {\n    \"entities\": [\n      {\n        \"id\": \"urn:ngsi-ld:Lamp:001\",\"type\": \"Lamp\"\n      }\n    ],\n    \"attrs\": [ \"on\", \"off\" ]\n  },\n  \"provider\": {\n    \"http\": {\"url\": \"http://{{iot-agent}}:4041\"},\n    \"legacyForwarding\": true\n  }\n}"
								},
								"url": {
									"raw": "http://{{orion}}:1026/v2/registrations?",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"registrations"
									],
									"query": [
										{
											"key": "type",
											"value": "Store",
											"description": "Entity type, to avoid ambiguity in case there are several entities with the same entity id",
											"disabled": true
										},
										{
											"key": "attrs",
											"value": "name",
											"description": "Ordered list of attribute names to display",
											"disabled": true
										}
									]
								},
								"description": "This example registers the `on` and `off` commands for the entity with\nthe `id=\"urn:ngsi-ld:Lamp:001\"`\n\nTo register the commands we need to inform Orion that the URL `http://orion:1026/v1` is able to provide\nthe missing  attributes. This will then be forwarded on to the IoT Agent. As you see this is an NGSI v1 \nendpoint and therefore the `legacyForwarding` attribute must also be set."
							},
							"response": []
						},
						{
							"name": "Switch On a Lamp",
							"request": {
								"method": "PATCH",
								"header": [
									{
										"key": "fiware-service",
										"value": "helixiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									},
									{
										"key": "Content-Type",
										"value": "application/json"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\n\t\"on\": {\n    \t\"type\" : \"command\",\n    \t\"value\" : \"\"\n\t}\n}"
								},
								"url": {
									"raw": "http://{{orion}}:1026/v2/entities/urn:ngsi-ld:Lamp:001/attrs",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"entities",
										"urn:ngsi-ld:Lamp:001",
										"attrs"
									]
								},
								"description": "To switch on the **Smart Lamp**, the `on` attribute must be updated in the context."
							},
							"response": []
						},
						{
							"name": "Lamp Status",
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "fiware-service",
										"value": "helixiot"
									},
									{
										"key": "fiware-servicepath",
										"value": "/"
									}
								],
								"url": {
									"raw": "http://{{orion}}:1026/v2/entities/urn:ngsi-ld:Lamp:001?options=keyValues",
									"protocol": "http",
									"host": [
										"{{orion}}"
									],
									"path": [
										"v2",
										"entities",
										"urn:ngsi-ld:Lamp:001"
									],
									"query": [
										{
											"key": "options",
											"value": "keyValues"
										}
									]
								},
								"description": "The result of the invocation of **Smart Lamp** commands can be read by querying the entity within the Orion Context Broker. \n\nThe `TimeInstant` shows last the time any command associated with the entity has been invoked. \n\n* The result of `on` command can be see in the value of the `on_info` attribute\n* The result of `off` command can be see in the value of the `off_info` attribute"
							},
							"response": []
						}
					],
					"description": "The **Smart Lamp** entity has been mapped to `id=\"urn:ngsi-ld:Lamp:001\"` with an entity `type=\"Lamp\"`",
					"event": [
						{
							"listen": "prerequest",
							"script": {
								"id": "5d5cbd31-cc55-4abd-a3b5-90be1a06ebad",
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						},
						{
							"listen": "test",
							"script": {
								"id": "aebaf411-d20a-4580-aee9-8484def536ad",
								"type": "text/javascript",
								"exec": [
									""
								]
							}
						}
					],
					"_postman_isSubFolder": true
				},
				{
					"name": "List Provisioned Devices",
					"request": {
						"method": "GET",
						"header": [
							{
								"key": "fiware-service",
								"value": "helixiot"
							},
							{
								"key": "fiware-servicepath",
								"value": "/"
							}
						],
						"url": {
							"raw": "http://{{orion}}:1026/v2/entities/",
							"protocol": "http",
							"host": [
								"{{orion}}"
							],
							"path": [
								"v2",
								"entities",
								""
							]
						},
						"description": "This example returns the data of all `Store` entities within the context data"
					},
					"response": []
				}
			],
			"description": "Having connected up the IoT Agent to the IoT devices, we now need to inform the Orion Context Broker that the commands\nare available. In other words we need to register the IoT Agent as a [Context Provider](https://github.com/Fiware/tutorials.Context-Providers/) for the command attributes.\n\nOnce the commands have been registered it will be possible to ring the **Bell**, open and close the **Smart Door** and\nswitch the **Smart Lamp** on and off by sending requests to the Orion Context Broker, rather than sending UltraLight 2.0\nrequests directly t the IoT devices as we did in the [previous tutorial](https://github.com/Fiware/tutorials.IoT-Sensors)",
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"id": "e5aa0b75-9618-464b-9547-bccf5360d530",
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"id": "862fb9fb-be99-4b36-bb84-8ec7f5638ede",
						"type": "text/javascript",
						"exec": [
							""
						]
					}
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"id": "e64b3c59-ab46-46cf-b504-30a027ca2986",
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"id": "04676146-332d-41b3-a65e-b9fd5a527aca",
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"id": "31dc8045-a1df-43b8-bad2-9d9a572a605a",
			"key": "iot-agent",
			"value": "HELIX_IOT_IP:4041",
			"type": "string"
		},
		{
			"id": "e89af194-6653-440f-9667-8fc89b631aa0",
			"key": "orion",
			"value": "HELIX_SANDBOX_IP:1026",
			"type": "string"
		}
	]
}
